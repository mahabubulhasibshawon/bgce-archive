# Class 46 : ЁЯР╣ Go Runtime

## ЁЯза Guide to RAM: Kernel Space vs User Space

ржХржорзНржкрж┐ржЙржЯрж╛рж░ ржЪрж╛рж▓рзБ рж╣рж▓рзЗ RAM (Random Access Memory) ржХрзЗ ржжрзБржЗржЯрж╛ ржнрж╛ржЧрзЗ ржнрж╛ржЧ ржХрж░рж╛ рж╣ржпрж╝:

-   ЁЯЫбя╕П **Kernel Space**
-   ЁЯСитАНЁЯТ╗ **User Space**

## ЁЯЫбя╕П Kernel Space:

ржПржЯрж╛ Operating System (OS) ржПрж░ ржирж┐ржЬрзЗрж░ ржЬржирзНржп allocated space

ржПржЦрж╛ржирзЗ ржерж╛ржХрзЗ:

-   OS ржПрж░ ржорзВрж▓ ржХрзЛржб (kernel code)
-   kernel data structures
-   page table (memory mapping ржПрж░ ржЬржирзНржп)

> Kernel рж╕ржм ржХрж┐ржЫрзБ access ржХрж░рждрзЗ ржкрж╛рж░рзЗред

### ЁЯФР Why it's protected?

-   ржпрж╛рждрзЗ user program ржЧрзБрж▓рзЛ kernel ржПрж░ sensitive ржЕржВрж╢рзЗ ржнрзБрж▓ ржХрж░рзЗ ржмрж╛ ржЗржЪрзНржЫрж╛ ржХрж░рзЗ access ржХрж░рждрзЗ ржирж╛ ржкрж╛рж░рзЗред
-   Security ржЖрж░ stability ржПрж░ ржЬржирзНржпред

### ЁЯзй Access from user programs

-   User program ржпржжрж┐ OS ржПрж░ help ржЪрж╛рзЯ, рждржЦржи system call ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзЗ (ржпрзЗржоржи `read()`, `write()`, `open()`).
-   рждржЦржи ржПржХржЯрж╛ software interrupt (ржпрзЗржоржи `0x80`) рждрзИрж░рж┐ рж╣ржпрж╝ред
-   ржПрждрзЗ CPU _user mode_ ржерзЗржХрзЗ _kernel mode_ ржП ржпрж╛рзЯ, kernel ржХрж╛ржЬржЯрж╛ ржХрж░рзЗ ржжрж┐рзЯрзЗ ржЖржмрж╛рж░ ржлрж┐рж░рзЗ ржЖрж╕рзЗред

### ЁЯз╡ Kernel Stack

-   ржпржЦржи kernel ржХрж╛ржЬ ржХрж░рзЗ, рждржЦржи ржПржХржЯрж╛ kernel stack ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзЗред
-   ржПржЯрж╛ рж╕ржм process ржорж┐рж▓рзЗ share ржХрж░рзЗред

## ЁЯСитАНЁЯТ╗ User Space:

RAM ржПрж░ ржПржЗ space тЖТ user application (ржпрзЗржоржи browser, notepad) ржПрж░ ржЬржирзНржпред

ржкрзНрж░рждрж┐ржЯрж╛ process рждрж╛рж░ ржирж┐ржЬрзЗрж░ ржПржХржЯрж╛ _virtual memory_ ржкрж╛рзЯред

ржПрж░ ржоржзрзНржпрзЗ ржерж╛ржХрзЗ:

-   **Code:** ржкрзНрж░рзЛржЧрзНрж░рж╛ржорзЗрж░ instruction
-   **Data:** global ржмрж╛ static variables
-   **Heap:** dynamic memory allocation (ржпрзЗржоржи `malloc`)
-   **Stack:** function call ржЖрж░ local variables

> тЪая╕П ржПржЗ space ржерзЗржХрзЗ kernel space рж╕рж░рж╛рж╕рж░рж┐ access ржХрж░рж╛ ржпрж╛рзЯ ржирж╛ред

## ЁЯзй System Call

-   System Call рж╣рж▓рзЛ ржПржХржзрж░ржирзЗрж░ function call
-   ржПрж░ ржорж╛ржзрзНржпржорзЗ ржХрзЛржи user program, Operating System ржПрж░ kernel ржерзЗржХрзЗ ржХрзЛржи service ржЪрж╛рзЯ
-   System Call ржПрж░ рж╕рж╛рж╣рж╛ржпрзНржп user mode ржерзЗржХрзЗ kernel mode ржП рж╕рзБржЗржЪ ржХрж░рзЗ OS ржПрж░ ржмрж┐рж╢рзЗрж╖ ржХрж╛ржЬржЧрзБрж▓рзЛ ржХрж░рж╛рж░ ржЕржирзБржорждрж┐ ржжрзЗржпрж╝

### тЪЩя╕П User Mode vs Kernel Mode

-   рж╕рж╛ржзрж╛рж░ржгржнрж╛ржмрзЗ program ржЪрж▓рзЗ user mode ржП, ржпрзЗржЦрж╛ржирзЗ resource access рж╕рзАржорж┐ржд ржерж╛ржХрзЗред
-   ржХрзЛржи special ржХрж╛ржЬ (ржпрзЗржоржи file read/write, process рждрзИрж░рж┐) ржХрж░рждрзЗ рж╣рж▓рзЗ system call ржжрж┐рждрзЗ рж╣рзЯ, рждржЦржи program kernel mode ржП ржпрж╛рзЯред

## тЬи Intro to Go Runtime

```bash
go build main.go
```

Go compiler:

-   main.go ржлрж╛ржЗрж▓ржЯрж╛ compile ржХрж░рзЗ
-   рждрж╛рж░ржкрж░ ржПржХржЯрж╛ binary executable file рждрзИрж░рж┐ ржХрж░рзЗ - рж╕рж╛ржзрж╛рж░ржгржнрж╛ржмрзЗ рж╕рзЗржЯрж╛ рж╣рзЯ `main` ржирж╛ржорзЗ (Linux/Unix-ржП)

```bash
./main
```

ржПржХржЯрж╛ process create рж╣рзЯ

**ЁЯФБ рж╕ржВржХрзНрж╖рзЗржкрзЗ flow:**

```plaintext
go build main.go   тЖТ  main (binary file)
./main             тЖТ  OS creates a process
                   тЖТ  program runs
```

### ЁЯУж Main Stack ржПржмржВ Stack Frame

-   Main thread ржПрж░ ржЬржирзНржп ржПржХржЯрж┐ stack рждрзИрж░рж┐ рж╣рзЯ - ржПржЯрж╛ржХрзЗ ржмрж▓рзЗ main stackред
-   Go runtime ржПрж░ function ржЧрзБрж▓рзЛрж░ ржЬржирзНржп ржПржЗ main stack ржП stack frames рждрзИрж░рж┐ рж╣рзЯред
-   Main thread тЖТ execute тЖТ go runtime stack

**ЁЯФ╣ Stack Frame:**
ржкрзНрж░рждрж┐ржЯрж╛ function call ржПрж░ ржЬржирзНржп ржПржХржЯрж╛ stack frame рждрзИрж░рж┐ рж╣рзЯред

Stack frame ржПрж░ ржоржзрзНржпрзЗ ржерж╛ржХрзЗ:

-   function ржПрж░ local variables,
-   return address (function рж╢рзЗрж╖рзЗ ржХрзЛржерж╛рзЯ ржлрж┐рж░рзЗ ржпрж╛ржмрзЗ),
-   ржХрж┐ржЫрзБ runtime bookkeeping dataред

**ЁЯФ╣Go Runtime -**

-   Memory allocate
-   Set up тЖТ Stack & Heap
-   Initialize тЖТ Go Scheduler
-   Go Runtime тЖТ System Call тЖТ Kernel тЖТ `epoll_create`

### ЁЯМА What is epoll in Linux?

-   `epoll` рж╣рж▓рзЛ Linux kernel ржПрж░ ржПржХржЯрж┐ I/O _event notification system_
-   ржПржЯрж┐ ржмрзНржпржмрж╣рж╛рж░ ржХрж░рж╛ рж╣рзЯ ржПржХрж╕рж╛ржерзЗ ржЕржирзЗржХржЧрзБрж▓рзЛ _file descriptor (fd)_ ржПрж░ ржУржкрж░ efficiently ржиржЬрж░ рж░рж╛ржЦрж╛рж░ ржЬржирзНржпред

> ржПржЯрж┐ `select()` ржмрж╛ `poll()` ржПрж░ ржерзЗржХрзЗ ржЖрж░ржУ scalable, efficient, ржПржмржВ fasterред

Linux-ржПрж░ epoll ржПрж░ ржорждрзЛ high-performance I/O event notification mechanisms ржЕржирзНржп OS-ржЧрзБрж▓рзЛрждрзЗржУ ржЖржЫрзЗ

#### ЁЯЦея╕П MacOS (Darwin/BSD) тЮд kqueue

-   Equivalent of epoll in macOS is kqueue.
-   ржПржЯрж┐ BSD-based systems (macOS, FreeBSD, OpenBSD) ржП ржмрзНржпржмрж╣рзГржд рж╣рзЯред

#### ЁЯкЯ Windows тЮд IOCP (I/O Completion Ports)

-   Windows-ржПрж░ equivalent рж╣рж▓ тЮд IOCP (I/O Completion Ports)ред

**ЁЯФ╣ IOCP-ржПрж░ ржХрж╛ржЬ:**

-   Asynchronous I/O operations handle ржХрж░рждрзЗ ржмрзНржпржмрж╣рзГржд рж╣рзЯред
-   Efficient ржПржмржВ scalable, especially high-performance servers-ржПрж░ ржЬржирзНржпред

### ЁЯза epoll ржХржмрзЗ ржжрж░ржХрж╛рж░ рж╣рзЯ?

-   Network socket
-   File
-   Pipe

ржЗрждрзНржпрж╛ржжрж┐ ржПржХрж╕рж╛ржерзЗ monitor ржХрж░рждрзЗ ржПржмржВ ржХрзЛржиржЯрж╛ read/write ржПрж░ ржЬржирзНржп ready рж╣рзЯрзЗржЫрзЗ

```plaintext
epfd = epoll_create1(0);                // epoll instance рждрзИрж░рж┐
epoll_ctl(epfd, ADD, sockfd, &event);   // ржХрзЛржи socket watch ржХрж░ржмрзЛ?
epoll_wait(epfd, events, MAX, timeout); // wait ржХрж░ржмрзЛ ржХржЦржи data ржЖрж╕ржмрзЗ
```

### ЁЯФз epoll ржПрж░ ржЬржирзНржп ржмрзНржпржмрж╣рзГржд рзйржЯрж┐ main syscall

**`epoll_create` / `epoll_create1`**

-   ржПржХржЯрж┐ ржирждрзБржи epoll instance рждрзИрж░рж┐ ржХрж░рзЗ ржПржмржВ ржПржХржЯрж┐ file descriptor (fd) рж░рж┐ржЯрж╛рж░рзНржи ржХрж░рзЗред
-   ржПржЗ fd ржХрзЗ ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзЗ ржЖржкржирж┐ ржкрж░ржмрж░рзНрждрзАрждрзЗ ржЗржнрзЗржирзНржЯ monitor ржХрж░ржмрзЗржиред

**`epoll_ctl`**

-   epoll instance ржП ржХрзЛржи file descriptor monitor ржХрж░рждрзЗ рж╣ржмрзЗ рж╕рзЗржЯрж╛ ржмрж▓рзЗ ржжрзЗрзЯред
-   ржЕрж░рзНржерж╛рзО: add / modify / delete operationред

**`epoll_wait`**

-   ржПржЯрж┐ block ржХрж░рзЗ (ржЕржкрзЗржХрзНрж╖рж╛ ржХрж░рзЗ) ржпрждржХрзНрж╖ржг ржирж╛ ржХрзЛржи monitored file descriptor ржерзЗржХрзЗ I/O event ржЖрж╕рзЗред
-   ржпржЦржи ржЖрж╕рзЗ, рждржЦржи рж╕рзЗржЗ event return ржХрж░рзЗ ржжрзЗрзЯред

### ЁЯП╖я╕П Scenario: epoll-based Non-blocking File Read in Linux

**Process & Threads**

-   P1: T1, T2
-   P2: T1
-   P3: T1, T2, T3

P1-T1 ржПржХржЯрж┐ ржлрж╛ржЗрж▓ ржкрзЬрждрзЗ ржЪрж╛рзЯ, ржЕрж░рзНржерж╛рзО I/O operation ржХрж░рждрзЗ ржЪрж╛рзЯред

ржЖржорж░рж╛ ржзрж░ржЫрж┐ ржПржЯрж╛ non-blocking I/O ржПржмржВ epoll ржмрзНржпржмрж╣рзГржд рж╣ржЪрзНржЫрзЗ (Linux system)ред

#### рззя╕ПтГг T1 ржлрж╛ржЗрж▓ ржкрзЬрждрзЗ ржЪрж╛рзЯ

-   T1 kernel-ржП read request ржкрж╛ржарж╛рзЯ, ржХрж┐ржирзНрждрзБ ржлрж╛ржЗрж▓ рждржЦржиржУ рж░рзЗржбрж┐ ржирж╛ред
-   рждрж╛ржЗ T1 ржмрж▓рзЗ, "ржлрж╛ржЗрж▓ рж░рзЗржбрж┐ рж╣рж▓рзЗ ржЖржорж╛ржХрзЗ ржЬрж╛ржирж┐ржУ" тАФ non-blocking mode

#### 2я╕ПтГг T1 syscall ржХрж░рзЗ тЖТ epoll_ctl

-   ржПржЯрж╛ ржжрж┐рзЯрзЗ kernel-ржХрзЗ ржЬрж╛ржирж╛ржирзЛ рж╣рзЯ:
-   "ржПржЗ ржлрж╛ржЗрж▓рзЗрж░ ржЬржирзНржп ржЖржорж┐ ржЕржкрзЗржХрзНрж╖рж╛ ржХрж░ржмрзЛред ржлрж╛ржЗрж▓ржЯрж╛ read ржХрж░рждрзЗ ржкрж╛рж░рж▓рзЗржЗ ржЖржорж╛ржХрзЗ ржбрж╛ржХрзЛред"

#### 3я╕ПтГг Kernel T1 ржХрзЗ ржШрзБржо ржкрж╛рзЬрж┐рзЯрзЗ ржжрзЗрзЯ

-   ржпрзЗрж╣рзЗрждрзБ ржлрж╛ржЗрж▓ ржПржЦржирзЛ рж░рзЗржбрж┐ ржирж╛, рждрж╛ржЗ kernel T1 ржХрзЗ sleep/wait ржХрж░рж┐рзЯрзЗ ржжрзЗрзЯред
-   T1 wait queue рждрзЗ ржЪрж▓рзЗ ржпрж╛рзЯ
-   рждржЦржи P1-ржПрж░ ржЕржирзНржп ржерзНрж░рзЗржб T2, ржмрж╛ ржЕржирзНржп ржкрзНрж░рж╕рзЗрж╕рзЗрж░ ржерзНрж░рзЗржбржЧрзБрж▓рзЛ рж╕рзНржмрж╛ржнрж╛ржмрж┐ржХржнрж╛ржмрзЗ ржХрж╛ржЬ ржХрж░рзЗ

#### 4я╕ПтГг kernel ржлрж╛ржЗрж▓ ржЪрзЗржХ ржХрж░рждрзЗ ржерж╛ржХрзЗ

-   kernel backend-ржП ржлрж╛ржЗрж▓ ready ржХрж┐ржирж╛ рж╕рзЗржЯрж╛ monitor ржХрж░рзЗред
-   ржпржЦржи ржлрж╛ржЗрж▓ржЯрж╛ readable рж╣рзЯрзЗ ржпрж╛рзЯ, рждржЦржи kernel ржлрж╛ржЗрж▓ржЯрж╛ load ржХрж░рзЗ, ржПржмржВ ржлрж╛ржЗрж▓рзЗрж░ ржЬржирзНржп file descriptor рждрзИрж░рж┐ ржХрж░рзЗ

#### 5я╕ПтГг kernel epoll ржХрзЗ notify ржХрж░рзЗ

-   kernel epoll_wait ржХрзЗ ржмрж▓рзЗ: "ржПржЗ file descriptor ржПржЦржи ready"
-   epoll_wait рждржЦржи рж╕рзЗржЗ FD ржХрзЗ ready list-ржП рж░рж╛ржЦрзЗ

#### 6я╕ПтГг epoll_wait Thread ржХрзЗ ржЬрж╛ржЧрж┐рзЯрзЗ рждрзЛрж▓рзЗ

_epoll_wait ржПрж░ ржХрж╛ржЬ:_

-   ржпрж╛рж░рж╛ ржЕржкрзЗржХрзНрж╖рж╛ ржХрж░ржЫрж┐рж▓, рждрж╛ржжрзЗрж░ ржЬрж╛ржирж┐рзЯрзЗ ржжрзЗрзЯрж╛ "рждрзЛржорж╛рж░ ржлрж╛ржЗрж▓ рж░рзЗржбрж┐"
-   T1 ржПржЦржи wake up рж╣рзЯ

#### 7я╕ПтГг T1 ржПржЦржи read(fd) ржжрж┐рзЯрзЗ ржлрж╛ржЗрж▓ ржкрзЬрзЗ

-   ржПржмрж╛рж░ T1 ржлрж╛ржЗрж▓ржЯрж┐ read ржХрж░рзЗ ржирзЗрзЯ file descriptor ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзЗ
-   File descriptor ржПржХржЯрж┐ token ржПрж░ ржорждрзЛ ржХрж╛ржЬ ржХрж░рзЗ тАФ ржПржЯрж┐ ржмрж▓рзЗ ржжрзЗрзЯ kernel-ржПрж░ ржХрзЛржи ржЬрж╛рзЯржЧрж╛ ржерзЗржХрзЗ ржлрж╛ржЗрж▓ ржкрзЬрждрзЗ рж╣ржмрзЗ

### ЁЯУж File descriptor

-   File descriptor рж╣ржЪрзНржЫрзЗ kernel-ржПрж░ ржПржХржЯрж┐ token ржмрж╛ ID ржпрж╛ file/socket-ржПрж░ represent ржХрж░рзЗред
-   User-space access ржХрж░рждрзЗ ржкрж╛рж░рзЗ ржирж╛, ржХрж┐ржирзНрждрзБ kernel ржЖрж░ Go runtime, file/socket ржХрзЗ ржЪрж┐ржирзЗ ржлрзЗрж▓рзЗ ржПржЗ FD ржжрж┐рзЯрзЗред

### ЁЯЪА Back to Go Runtime Story

**1. Go Runtime рж╢рзБрж░рзБрждрзЗржЗ ржХрзА ржХрж░рзЗ?**

-   Go runtime ржирж┐ржЬрзЗрж░ ржоржзрзНржпрзЗ ржПржХржЯрж╛ epoll instance рждрзИрж░рж┐ ржХрж░рзЗ (epoll_create syscall ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзЗ)ред
-   ржпржЦржи epoll рждрзИрж░рж┐ ржХрж░рзЗ, рждржЦржи kernel-ржХрзЗ ржмрж▓рзЗ ржжрзЗрзЯ ржХрждржЧрзБрж▓рзЛ file descriptor (FD) ржПржХрж╕рж╛ржерзЗ ржкрзЬрждрзЗ ржЪрж╛рзЯ
    -   Go Runtime kernel-ржХрзЗ ржмрж▓рзЗ ржжрзЗрзЯ 100 file descriptor (FD) ржПржХрж╕рж╛ржерзЗ ржкрзЬрждрзЗ ржЪрж╛рзЯ
    -   Max 100 FD read ржХрж░рж╛рж░ ржЬржирзНржп `epoll_ctl` send ржХрж░рж╛ ржпрж╛ржмрзЗ kernel ржПрж░ ржХрж╛ржЫрзЗ
    -   100 FD list ржЖржХрж╛рж░рзЗ epoll_wait thread ржХрзЗ ржжрж┐рзЯрзЗ ржжрж┐ржмрзЗ
    -   `epoll_wait` thread FD list Go runtime ржХрзЗ ржжрж┐рзЯрзЗ ржжрж┐ржмрзЗ
-   ржПржЗ instance handle ржХрж░рзЗ рж╕ржм network I/O ржмрж╛ file I/O ржЕржкрж╛рж░рзЗрж╢ржиред
-   ржПрж░ржкрж░ Go runtime ржПржХржЯрж┐ ржЖрж▓рж╛ржжрж╛ OS thread рждрзИрж░рж┐ ржХрж░рзЗ ржпрзЗржЦрж╛ржирзЗ `epoll_wait` ржмрж╕рзЗ ржерж╛ржХрзЗред ржПржЗ ржерзНрж░рзЗржбржХрзЗ ржмрж▓рж╛ ржпрж╛рзЯ "Netpoller Thread"ред

**2. ржПржХржЯрж┐ goroutine file/socket read ржХрж░рждрзЗ ржЪрж╛рзЯ**

-   main goroutine (ржпрзЗржоржи `go func() { conn.Read() }`) socket ржерзЗржХрзЗ ржХрж┐ржЫрзБ ржкрзЬрждрзЗ ржЪрж╛рзЯред
-   ржпржжрж┐ data рждржЦржиржЗ available ржирж╛ ржерж╛ржХрзЗ, Go runtime:
    -   ржУржЗ goroutine ржХрзЗ block ржирж╛ ржХрж░рзЗ park (ржШрзБржо ржкрж╛рзЬрж┐рзЯрзЗ) ржжрзЗрзЯред
    -   ржПржХржЗрж╕рж╛ржерзЗ, рж╕рзЗржЗ socket ржмрж╛ file descriptor ржХрзЗ epoll instance-ржП register ржХрж░рзЗ рж░рж╛ржЦрзЗ (`epoll_ctl` ржжрж┐рзЯрзЗ)ред

**3. epoll_wait ржХрзА ржХрж░рзЗ?**

-   ржЖрж▓рж╛ржжрж╛ Netpoller Thread рж╕ржмрж╕ржорзЯ epoll_wait syscall ржЪрж╛рж▓рж┐рзЯрзЗ ржШрзБржорж┐рзЯрзЗ ржерж╛ржХрзЗред
-   ржпржЦржи kernel detect ржХрж░рзЗ ржпрзЗ socket/data ready, рждржЦржи рж╕рзЗржЗ Netpoller Thread ржХрзЗ wake ржХрж░рзЗ ржжрж┐рзЯрзЗ data ржжрзЗрзЯред
-   ржПрж░ржкрж░ Netpoller ржЬрж╛ржирж╛рзЯ ржпрзЗ fd readyред

**4. Go Runtime ржкрзБржирж░рж╛рзЯ goroutine ржЪрж╛рж▓рзБ ржХрж░рзЗ**

-   Go runtime ржмрзБржЭрзЗ ржпрж╛рзЯ ржпрзЗ ржпрзЗ goroutine file/socket read ржХрж░рждрзЗ ржЪрзЗрзЯрзЗржЫрж┐рж▓ рждрж╛рж░ data ржПрж╕рзЗ ржЧрзЗржЫрзЗред
-   рждрж╛ржХрзЗ ржЖржмрж╛рж░ runnable ржХрж░рзЗ ржжрзЗрзЯ, ржПржмржВ data ржкрзЬрж╛ рж╢рзБрж░рзБ рж╣рзЯред

### тЪЩя╕П Setting Up Garbage Collector (GC)

-   Go runtime GC ржЪрж╛рж▓рж╛ржирзЛрж░ ржЬржирзНржп ржЖрж▓рж╛ржжрж╛ OS thread ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзЗ, ржпрж╛рждрзЗ ржкрзНрж░рзЛржЧрзНрж░рж╛ржорзЗрж░ ржорзВрж▓ ржХрж╛ржЬ ржмрж┐ржШрзНржи ржирж╛ ржШржЯрзЗ
-   thread ржЧрзБрж▓рзЛ background-ржП silently ржХрж╛ржЬ ржХрж░рзЗ memory clean рж░рж╛ржЦрзЗ
-   Go Runtime ржкрзБрж░рзЛржкрзБрж░рж┐ GC thread control ржХрж░рзЗ

### ЁЯза Go Scheduling

Go runtime M:P:G model scheduling follow ржХрж░рзЗ, ржпрзЗржЦрж╛ржирзЗ

-   M = Machine (OS-level Thread) тАФ ржпрзЗржЯрж╛ ржмрж╛рж╕рзНрждржмрзЗ CPU-рждрзЗ ржХрж╛ржЬ ржЪрж╛рж▓рж╛рзЯред
-   P = Processor (Logical Processor) тАФ ржПржЯрж┐ goroutine run ржХрж░рж╛рж░ ржЬржирзНржп ржкрзНрж░рзЯрзЛржЬржирзАрзЯ execution context ржзрж░рзЗ рж░рж╛ржЦрзЗ, ржпрзЗржоржи: local run queue, stack, scheduler info ржЗрждрзНржпрж╛ржжрж┐ред
-   G = Goroutine тАФ ржЖржорж░рж╛ ржпрзЗрж╕ржм Go function/logic concurrently ржЪрж╛рж▓рж╛ржЗ, ржПржЧрзБрж▓рзЛржХрзЗ Go runtime тАЬgoroutineтАЭ ржирж╛ржорзЗ ржЪрж╛рж▓рж╛рзЯред

#### ЁЯПЧя╕П Go Scheduler Initialization

**M (Machine, ржмрж╛ OS Thread) рждрзИрж░рж┐**

Go runtime рж╢рзБрж░рзБрждрзЗржЗ exactly vCPU рж╕ржВржЦрзНржпржХ machine thread (M) рждрзИрж░рж┐рж░ ржЬржирзНржп OS ржХрзЗ request ржХрж░рзЗред

-   1 core тЖТ 2 vCPU тЖТ 2 M
-   2 core тЖТ 4 vCPU тЖТ 4 M

**P (Logical Processor) рждрзИрж░рж┐**

ЁЯФ╣ Go runtime M рж╕ржВржЦрзНржпржХ "Logical Processor" рждрзИрж░рж┐ ржХрж░рзЗ, ржпрж╛ржХрзЗ P ржмрж▓рж╛ рж╣рзЯ

-   4 M : 4 P

ЁЯФ╣ ржПржЗ P ржЧрзБрж▓рзЛ ржжрзЗржЦрждрзЗ ржЕржирзЗржХржЯрж╛ Virtual CPU (vCPU) ржПрж░ ржорждрзЛ

ЁЯФ╣ ржХрж┐ржирзНрждрзБ ржПржЧрзБрж▓рзЛ hardware vCPU ржирж╛, ржмрж░ржВ Go runtime ржПрж░ internal scheduling unit

**G (Goroutine) рждрзИрж░рж┐**

ЁЯФ╕ Go runtime-ржПрж░ рж╕ржмржЪрзЗрзЯрзЗ lightweight execution unit рж╣ржЪрзНржЫрзЗ Goroutine (G)

ЁЯФ╕ ржкрзНрж░рждрж┐ржЯрж┐ `go someFunction()` ржХрж▓ ржХрж░рж▓рзЗ ржирждрзБржи ржПржХржЯрж╛ goroutine рждрзИрж░рж┐ рж╣рзЯ

### ЁЯзй Go Scheduler: 1M : 1P : 2G Diagram

ржоржирзЗ ржХрж░рж┐, 1M:1P:2G тАФ ржПржмржВ ржоржирзЗ рж╣ржЪрзНржЫрзЗ 1P ржжрзБржЗржЯрж╛ goroutine ржПржХрж╕рж╛ржерзЗ ржЪрж╛рж▓рж╛ржЪрзНржЫрзЗ, ржЖрж░ 1M ржЪрж╛рж▓рж╛ржЪрзНржЫрзЗ рж╕рзЗржЗ 1P-ржХрзЗ

```markdown
                        тФМтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФР
                        тФВ   Machine M  тФВ  тЖР OS Thread (Executes G via P)
                        тФФтФАтФАтФАтФАтФАтФАтФмтФАтФАтФАтФАтФАтФАтФАтФШ
                               тФВ
                               тЦ╝
                        тФМтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФР
                        тФВ Logical P    тФВ  тЖР Holds G run queue
                        тФФтФАтФАтФАтФАтФАтФАтФмтФАтФАтФАтФАтФАтФАтФАтФШ
                               тФВ
                тФМтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФ┤тФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФР
                тЦ╝                             тЦ╝
        тФМтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФР             тФМтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФР
        тФВ Goroutine G1 тФВ             тФВ Goroutine G2 тФВ
        тФФтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФШ             тФФтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФАтФШ
```

### ЁЯза 1 Core Scenario in Go Scheduler

#### тЬЕ Initialization Phase:

-   OS ржерзЗржХрзЗ ржкрж╛ржУржпрж╝рж╛ ржпрж╛рзЯ тЖТ 1 Core тЗТ 2 vCPU
-   рждрж╛ржЗ Go runtime рждрзИрж░рж┐ ржХрж░рзЗ:
    -   2 Machine Thread (M)
    -   2 Logical Processor (P)

```markdown
          ЁЯза Physical Core (1)
                тФВ
        тХФтХРтХРтХРтХРтХРтХРтХРтХзтХРтХРтХРтХРтХРтХРтХРтХРтХЧ
        тЦ╝                тЦ╝
     M1 (Thread)      M2 (Thread)
       тФВ                 тФВ
       тЦ╝                 тЦ╝
    тФМтФАтФАтФАтФАтФАтФР           тФМтФАтФАтФАтФАтФАтФР
    тФВ  P1 тФВ           тФВ  P2 тФВ
    тФФтФАтФмтФАтФАтФАтФШ           тФФтФАтФмтФАтФАтФАтФШ
      тФВ                 тФВ

тФМтФАтФАтФАтЦ╝тФАтФАтФАтФР тФМтФАтФАтФАтЦ╝тФАтФАтФАтФР
тФВ G1,G2 тФВ тФВ G3,G4 тФВ тЖР Each P has its G queue
тФФтФАтФАтФАтФАтФАтФАтФАтФШ тФФтФАтФАтФАтФАтФАтФАтФАтФШ
```

### ЁЯзк Run Queue

Go ржПрж░ scheduler-ржП рзи ржзрж░ржирзЗрж░ run queue ржерж╛ржХрзЗ

### ЁЯз╡ рзз. Local Run Queue (per P)

ржкрзНрж░рждрж┐ржЯрж┐ Logical Processor (P) ржПрж░ ржирж┐ржЬрж╕рзНржм ржПржХржЯрж┐ Run Queue ржерж╛ржХрзЗ, ржпрзЗржЦрж╛ржирзЗ goroutine (G) ржЧрзБрж▓рзЛ рж░рж╛ржЦрж╛ рж╣рзЯред

#### ЁЯзй ржХрзАржнрж╛ржмрзЗ ржХрж╛ржЬ ржХрж░рзЗ:

-   ржкрзНрж░рждрж┐ржЯрж┐ P ржПржХржЯрж┐ fixed-size circular run queue ржорзЗржЗржиржЯрзЗржЗржи ржХрж░рзЗ ржпрж╛ ring ржПрж░ ржорждрзЛ
-   ржкрзНрж░рждрж┐ржЯрж┐ Local Run Queue ржПрж░ slot 256 тЖТ 256 goroutine
-   ржкрзНрж░рждрж┐ржЯрж┐ P рждрж╛рж░ queue ржПрж░ G ржЧрзБрж▓рзЛржХрзЗ FIFO ржнрж┐рждрзНрждрж┐рждрзЗ ржЪрж╛рж▓рж╛рзЯ (First-In-First-Out).
-   ржпрзЗржЗ P ржмрж░рзНрждржорж╛ржирзЗ M ржжрзНржмрж╛рж░рж╛ ржЪрж╛рж▓рж┐ржд рж╣ржЪрзНржЫрзЗ, рж╕рзЗржЗ P рждрж╛рж░ queue ржерзЗржХрзЗ goroutine G ржирж┐рзЯрзЗ ржЪрж╛рж▓рж╛рзЯред
-   ржпржжрж┐ ржХрзЛржи G ржмрзНрж▓ржХ ржХрж░рзЗ (I/O, sleep etc), рждрж╛рж╣рж▓рзЗ P ржЖржмрж╛рж░ queue ржерзЗржХрзЗ ржирждрзБржи G ржЪрж╛рж▓рж╛рзЯред
-   ржпржжрж┐ P ржПрж░ queue ржЦрж╛рж▓рж┐ рж╣рзЯрзЗ ржпрж╛рзЯ, рждрж╛рж╣рж▓рзЗ:
    -   рж╕рзЗ `work stealing` ржХрж░рзЗ тАФ ржЕржирзНржп P ржПрж░ queue ржерзЗржХрзЗ G ржЪрзБрж░рж┐ ржХрж░рзЗ ржирзЗрзЯред

### ЁЯМН рзи. Global Run Queue

ржпрзЗрж╕ржм goroutine-ржХрзЗ ржХрзЛржирзЛ ржирж┐рж░рзНржжрж┐рж╖рзНржЯ P-рждрзЗ assign ржХрж░рж╛ ржпрж╛рзЯ ржирж╛, рж╕рзЗржЧрзБрж▓рзЛ Global Run Queue-рждрзЗ рж░рж╛ржЦрж╛ рж╣рзЯред

-   System-wide queue, рж╕ржм P access ржХрж░рждрзЗ ржкрж╛рж░рзЗред
-   Locking ржжрж░ржХрж╛рж░ ржкрзЬрзЗ, рждрж╛ржЗ ржПржХржЯрзБ ржзрзАрж░ред
-   ржпржЦржи ржХрзЛржирзЛ P-рж░ local queue ржЦрж╛рж▓рж┐ рж╣рзЯ, рждржЦржи рж╕рзЗ Global queue ржерзЗржХрзЗ ржХрж╛ржЬ ржирзЗрзЯред

> ЁЯФР Locking рж╣ржЪрзНржЫрзЗ ржПржоржи ржПржХржЯрж╛ ржмрзНржпржмрж╕рзНржерж╛, ржпрзЗржЯрж╛ ржжрж┐рзЯрзЗ ржПржХржЗ рж╕ржорзЯ ржПржХрж╛ржзрж┐ржХ goroutine ржпрзЗржи ржПржХрж╕рж╛ржерзЗ ржПржХржЗ ржЬрж┐ржирж┐рж╕рзЗ рж╣рж╛ржд ржирж╛ ржжрж┐рждрзЗ ржкрж╛рж░рзЗ, рж╕рзЗржЯрж╛ ржирж┐рж╢рзНржЪрж┐ржд ржХрж░рж╛ рж╣рзЯред

-   newly created goroutines ржпрзЗ local run queue рждрзЗ ржЬрж╛рзЯржЧрж╛ ржкрж╛ржмрзЗ ржмрж╕рзЗ ржпрж╛ржмрзЗред
-   logical processor free ржерж╛ржХрж▓рзЗ local run queue ржерзЗржХрзЗ goroutine ржирж┐рзЯрзЗ execute ржХрж░рждрзЗ ржерж╛ржХрзЗред
-   ржкрзНрж░рждрж┐ржЯрж┐ local run queue ржПржХржЯрж┐ ржХрж░рзЗ goroutine execute ржХрж░рзЗ ржПржмржВ slot ржЧрзБрж▓рзЛрждрзЗ 256 ржЯрж┐ ржХрж░рзЗ goroutines ржерж╛ржХрж▓рзЗ newly created goroutines ржЧрзБрж▓рзЛ global run queue рждрзЗ ржЧрж┐рзЯрзЗ ржмрж╕рзЗ
-   ржпржжрж┐ local run queue ржЦрж╛рж▓рж┐ рж╣рзЯрзЗ ржпрж╛рзЯ, рждрж╛рж╣рж▓рзЗ рж╕рзЗ ржЕржирзНржп P ржПрж░ queue ржерзЗржХрзЗ half goroutines ржирж┐рзЯрзЗ ржирзЗрзЯ (this is called `Work Stealing`).

-   ржХрзЛржи processor free рж╣рж▓рзЗ ржПржмржВ ржПрж░ local run queue рждрзЗ ржХрзЛржи goroutine ржирж╛ ржерж╛ржХрж▓рзЗ, ржПржмржВ ржЕржирзНржп logical processor ржПрж░ local run queue рждрзЗржУ goroutines ржирж╛ ржерж╛ржХрж▓рзЗ (ржПржХрзНрж╖рзЗрждрзНрж░рзЗ work stealing ржХрж░рждрзЗ ржкрж╛рж░рзЗржирж╛) ржПржЯрж┐ global run queue ржерзЗржХрзЗ goroutines ржирж┐рзЯрзЗ execute ржХрж░рзЗ

### ЁЯФ╣ Execution of `main.go`

```go
package main

import (
	"fmt"
	"net/http"
)

func handler(w http.ResponseWriter, r *http.Request) {
	w.Header().Set("Content-Type", "application/json")
	fmt.Fprintln(w, "hello world")
}

func aboutHandler(w http.ResponseWriter, r *http.Request) {
	fmt.Fprintln(w, "About page")
}

func main() {
	mux := http.NewServeMux()
	mux.HandleFunc("/", handler)
	mux.HandleFunc("/about", aboutHandler)

	fmt.Println("Server running on :8080")
	err := http.ListenAndServe(":8080", mux)
	if err != nil {
		fmt.Println("Error starting server", err)
	}
}
```

```bash
go build main.go
./main
```

#### ЁЯУж Go Program Memory Layout

```markdown
                        +----------------------------+
                        |        Code Segment        |
                        |----------------------------|
                        | - func handler             |
                        | - func aboutHandler        |
                        | - func main                |
                        | - imported fmt, net/http   |
                        +----------------------------+

                        +----------------------------+
                        |       Data Segment         |
                        |----------------------------|
                        | - Static/global data       |
                        | - Function/method metadata |
                        | - String constants         |
                        |   e.g., "hello world"      |
                        |         "About page"       |
                        |         ":8080"            |
                        +----------------------------+

                        +----------------------------+
                        |           Heap             |
                        |----------------------------|
                        | - Dynamically allocated    |
                        |   memory during runtime    |
                        | - mux := http.NewServeMux()|
                        | - Each request's data      |
                        | - Goroutines' data         |
                        +----------------------------+

                        +----------------------------+
                        |           Stack            |
                        |----------------------------|
                        | - Go Runtime Code          |
                        |                            |
                        +----------------------------+
```

### ЁЯМА Go HTTP Server Execution

**ЁЯФ╣ рзз. Go рж░рж╛ржиржЯрж╛ржЗржо ржЪрж╛рж▓рзБ рж╣ржУржпрж╝рж╛рж░ рж╢рзБрж░рзБрждрзЗ:**

-   Go ржкрзНрж░рзЛржЧрзНрж░рж╛ржо ржЪрж╛рж▓рзБ рж╣рж▓рзЗ:
    -   ржкрзНрж░ржержорзЗ **init()** ржлрж╛ржВрж╢ржиржЧрзБрж▓рзЛ (ржпржжрж┐ ржерж╛ржХрзЗ) execute рж╣ржпрж╝ред
    -   ржПрж░ржкрж░ memory layout ржЕржирзБржпрж╛ржпрж╝рзА code segment, data segment, ржЗрждрзНржпрж╛ржжрж┐ рж╕рзЗржЯржЖржк рж╣ржпрж╝ред

**ЁЯФ╣ рзи. Main Thread & Stack Setup**

-   Go runtime ржПржХржЯрж╛ main OS thread рждрзИрж░рж┐ ржХрж░рзЗред
-   ржПржЗ ржерзНрж░рзЗржбрзЗрж░ ржЬржирзНржп ржПржХржЯрж╛ main stack allocate ржХрж░рзЗред
-   ржПржЗ stack-ржП runtime code ржУ ржЕржирзНржпрж╛ржирзНржп execution ржЪрж▓ржмрзЗред

**ЁЯФ╣ рзй. Main Goroutine рждрзИрж░рж┐**

-   Go automatically ржПржХржЯрж╛ main goroutine рждрзИрж░рж┐ ржХрж░рзЗред
-   ржПрж░ initial stack size рж╣рзЯ 2KB (heap-ржП allocate ржХрж░рж╛ рж╣рзЯ)ред
-   ржПржЗ goroutine ржерж╛ржХржмрзЗ local run queue-рждрзЗред

**ЁЯФ╣ рзк. Scheduler ржПржмржВ Processor**

-   Go runtime-ржП ржЖржЫрзЗ:
    -   M (Machine = Thread)
    -   P (Processor = Logical executor)
    -   G (Goroutine)
-   ржпржЦржи Go start рж╣рзЯ, main goroutine local run queue рждрзЗ enqueue рж╣рзЯред
-   ржПржХржЯрж┐ P (logical processor) active ржерж╛ржХрзЗ тАФ рж╢рзБржзрзБ рж╕рзЗ ржХрж╛ржЬ ржХрж░рзЗ ржХрж╛рж░ржг ржПржЗ ржорзБрж╣рзВрж░рзНрждрзЗ ржПржХржорж╛рждрзНрж░ main goroutine-ржЯрж╛ржЗ activeред
-   ржЕржирзНржп P ржЧрзБрж▓рзЛ sleep ржХрж░рзЗ ржерж╛ржХржмрзЗ ржпржжрж┐ ржЖрж░ ржХрзЛржирзЛ goroutine ржирж╛ ржерж╛ржХрзЗред

**ЁЯФ╣ рзл. main() Function Execution рж╢рзБрж░рзБ**

-   Main goroutine-ржПрж░ ржнрж┐рждрж░:
    -   main() function-ржПрж░ ржЬржирзНржп ржПржХржЯрж╛ stack frame рждрзИрж░рж┐ рж╣рзЯред
    -   рждрж╛рж░ржкрж░ main() ржлрж╛ржВрж╢ржирзЗрж░ ржнрж┐рждрж░рзЗрж░ ржХрзЛржб execute рж╣рждрзЗ ржерж╛ржХрзЗред

**ЁЯФ╣ рзм. Router Creation**

-   http.NewServeMux() ржХрж▓ ржХрж░рж╛ рж╣рзЯ:
    -   ржПржЯрж┐ ржПржХржЯрж┐ ServeMux object рждрзИрж░рж┐ ржХрж░рзЗред
    -   ржПржЗ object ржЯрж┐ main goroutine-ржПрж░ stack frame ржП ржерж╛ржХрзЗред

**ЁЯФ╣ рзн. Route Register**

-   mux.Handle("/", handler):
    -   Mux object-ржПрж░ ржнрж┐рждрж░рзЗ route pattern ржУ handler function register рж╣рзЯред
    -   ржПржЧрзБрж▓рзЛ map ржЖржХрж╛рж░рзЗ ServeMux struct-ржП store рж╣рзЯред

**ЁЯФ╣ рзо. Server Start**

-   http.ListenAndServe(":8080", mux):
    -   ржПржЯрж╛ main goroutine ржерзЗржХрзЗ call рж╣рзЯред
    -   ржПрж░ ржЬржирзНржп ржПржХржЯрж┐ ржирждрзБржи stack frame рждрзИрж░рж┐ рж╣рзЯред

**ЁЯФ╣ рзп. Internal serve() Call**

-   ListenAndServe() ржПрж░ ржнрж┐рждрж░:
    -   srv.Serve(l net.Listener) function call рж╣рзЯред
    -   ржПрж░ ржЬржирзНржп ржЖрж░рзЗржХржЯрж┐ stack frame рждрзИрж░рж┐ рж╣рзЯред

**ЁЯФВ ЁЯФБ рззрзж. Server-ржПрж░ Infinite Loop**

-   Serve() function-ржПрж░ ржнрж┐рждрж░рзЗ ржерж╛ржХрзЗ ржПржХржЯрж┐ infinite for loop:
    -   ржпрзЗржЯрж╛ ржкрзНрж░рждрж┐ iteration-ржП ржХрж░рзЗ:
        -   Accept() ржХрж░рзЗ ржирждрзБржи connectionред
        -   ржкрзНрж░рждрж┐ржЯрж┐ connection ржПрж░ ржЬржирзНржп ржирждрзБржи goroutine рждрзИрж░рж┐ ржХрж░рзЗред
        -   рж╕рзЗржЗ goroutine handle ржХрж░рзЗ HTTP request-responseред

```markdown
Program Start
тФВ
тФЬтФА> Execute init()
тФЬтФА> Setup code/data segment
тФЬтФА> Create main thread + main stack
тФЬтФА> Create main goroutine (2KB heap stack)
тФВ
тФФтФА> main goroutine enqueued тЖТ local run queue тЖТ executed by P

Main Goroutine:
тФВ
тФЬтФА> main() stack frame created
тФВ тФЬтФА> mux := http.NewServeMux()
тФВ тФЬтФА> mux.Handle("/", handler)
тФВ тФФтФА> http.ListenAndServe(":8080", mux)
тФВ тФФтФА> srv.Serve(listener)
тФВ тФФтФА> infinite for loop
тФВ тФФтФА> accept conn тЖТ new goroutine тЖТ handle request
```

```go
for {
    rw, err := l.Accept()
    go c.serve(connCtx)
}
```

### ЁЯза Go HTTP Server accepts connection and handles it

**ЁЯФ╣ рзз. l.Accept() ржХрж▓ рж╣рзЯ**

-   ржПржЯрж┐ ржПржХржЯрж┐ network socket accept callред
-   ржПрж░ ржЬржирзНржп ржПржХржЯрж┐ ржирждрзБржи stack frame рждрзИрж░рж┐ рж╣ржпрж╝ред
-   ржПрж░ ржХрж╛ржЬ рж╣ржЪрзНржЫрзЗ:
    -   ржирждрзБржи ржХрзЗржЙ connect ржХрж░рждрзЗ ржЪрж╛ржЗрж▓рзЗ, рждрж╛рж░ рж╕рж╛ржерзЗ communication рж╢рзБрж░рзБ ржХрж░рж╛ред

**ЁЯФ╣ рзи. Accept() ржХрзА ржХрж░рзЗ?**

-   main goroutine тЖТ Accept() call ржХрж░рзЗ тЖТ ржПржЯрж┐ Go runtime ржХрзЗ ржмрж▓рзЗ:
    -   тАЬржЖржорж╛ржХрзЗ ржПржХржЯрж╛ socket ржжрж╛ржУ, ржпрж╛рждрзЗ ржЖржорж┐ ржирждрзБржи connection handle ржХрж░рждрзЗ ржкрж╛рж░рж┐редтАЭ
    -   Go runtime рждржЦржи ржжрзЗржЦрзЗ, тАЬржЖржорж╛рж░ ржХрж╛ржЫрзЗ ржХрж┐ socket ржЖржЧрзЗ ржерзЗржХрзЗржЗ ready ржЖржЫрзЗ?тАЭ

**ЁЯФ╣ рзй. Socket ржирж╛ ржерж╛ржХрж▓рзЗ ржХрзА рж╣рзЯ?**

-   ржпржжрж┐ socket ржирж╛ ржерж╛ржХрзЗ:
    -   Go runtime тЖТ epoll_ctl() call ржХрж░рзЗ тЖТ kernel ржХрзЗ ржмрж▓рзЗ:
        -   тАЬрждрзБржорж┐ ржПржХржЯрж╛ socket рждрзИрж░рж┐ ржХрж░рзЛ ржПржмржВ future-ржП ready рж╣рж▓рзЗ ржЖржорж╛ржХрзЗ ржЬрж╛ржирж┐ржУредтАЭ
-   ржПржЗ ржХрж╛ржЬржЯрж╛ Go-ржПрж░ netpoll library ржПрж░ ржорж╛ржзрзНржпржорзЗ ржХрж░рж╛ рж╣рзЯред

**ЁЯФ╣ рзк. epoll_ctl тЖТ kernel**

-   epoll_ctl() ржПржХржЯрж╛ asynchronous system call:
    -   ржорж╛ржирзЗ ржПржЯрж╛ main goroutine ржХрзЗ block ржХрж░рзЗ ржирж╛ред
    -   Go runtime meanwhile ржЕржирзНржпрж╛ржирзНржп ржХрж╛ржЬ ржЪрж╛рж▓рж╛рждрзЗ ржкрж╛рж░рзЗред

**ЁЯФ╣ рзл. Linux kernel ржХрзА ржХрж░рзЗ?**

-   Linux-ржП рж╕ржмржХрж┐ржЫрзБ file рж╣рж┐рж╕рзЗржмрзЗ treat ржХрж░рж╛ рж╣ржпрж╝ (socket, file, device тАФ рж╕ржмржХрж┐ржЫрзБ)ред
-   Kernel ржПржХржЯрж┐ socket рждрзИрж░рж┐ ржХрж░рзЗ тАФ ржПржЯрж╛ ржПржХ ржкрзНрж░рж╛ржирзНржд ржпрж╛ ржжрж┐рзЯрзЗ data ржкрж╛ржарж╛ржирзЛ ржУ ржЧрзНрж░рж╣ржг ржХрж░рж╛ ржпрж╛ржпрж╝ (like pipe)ред
-   ржПржЗ socket-ржПрж░ ржЬржирзНржп kernel ржПржХржЯрж┐ file descriptor (FD) ржжрзЗржпрж╝ред
    -   ржпрзЗржоржи, ржзрж░рзЛ FD = 5

**ЁЯФ╣ рзм. Main Thread Sleep ржХрж░рзЗ**

-   main goroutine рждржЦржи sleep ржХрж░рзЗ ржерж╛ржХрзЗ, ржХрж╛рж░ржг рж╕рзЗ ржЕржкрзЗржХрзНрж╖рж╛ ржХрж░ржЫрзЗ ржирждрзБржи socket connection-ржПрж░ ржЬржирзНржпред
-   ржХрж┐ржирзНрждрзБ ржПржЗ рж╕ржорзЯрзЗржУ Go runtime ржмржирзНржз рж╣ржпрж╝ ржирж╛ тАФ ржЕржирзНржпрж╛ржирзНржп goroutine ржЧрзБрж▓рзЛ ржЪрж╛рж▓рзБ ржерж╛ржХрждрзЗ ржкрж╛рж░рзЗред

**ЁЯФ╣ рзн. New Connection ржПрж▓рзЗ**

-   ржХрзЗржЙ ржпржЦржи connect ржХрж░рзЗ:
    -   Kernel ржмрж▓рзЗ: тАЬржПржЗ socket (FD 5) now ready!тАЭ
    -   Go runtime ржПрж░ netpoller ржЬрзЗржЧрзЗ ржЙржарзЗ (via epoll_wait) ржПржмржВ рж╕рзЗржЗ connection ржЧрзНрж░рж╣ржг ржХрж░рзЗред

**ЁЯФ╣ рзо. New goroutine handle ржХрж░рзЗ**

-   рждрж╛рж░ржкрж░ Go runtime:
    -   `go c.serve(connCtx)` ржХрж▓ ржХрж░рзЗ
    -   ржирждрзБржи goroutine рждрзИрж░рж┐ рж╣ржпрж╝ тЖТ ржПржЯрж┐ рж╕рзЗржЗ connection ржПрж░ request/response handle ржХрж░рзЗ

| Step | Description                                        |
| ---- | -------------------------------------------------- |
| 1я╕ПтГг   | `Accept()` call тЖТ ржирждрзБржи connection ржЪрж╛ржЗ              |
| 2я╕ПтГг   | Go runtime checks тЖТ socket available?              |
| 3я╕ПтГг   | ржирж╛ ржерж╛ржХрж▓рзЗ тЖТ `epoll_ctl()` тЖТ kernel socket рждрзИрж░рж┐      |
| 4я╕ПтГг   | Kernel тЖТ socket рждрзИрж░рж┐ ржХрж░рзЗ (e.g. FD = 5)             |
| 5я╕ПтГг   | main goroutine sleeps тЖТ non-blocking epoll         |
| 6я╕ПтГг   | New connection ржПрж▓рзЗ тЖТ `epoll_wait` wakes Go runtime |
| 7я╕ПтГг   | `go c.serve()` тЖТ new goroutine handles request     |

### ЁЯМР ржпржЦржи ржПржХржЯрж┐ HTTP Request ржХрж░рж╛ рж╣ржпрж╝ тАФ ржнрж┐рждрж░рзЗрж░ ржЬржЧрзО (Go HTTP Server + OS + NIC + Kernel)

**ЁЯФ╣ рзз. ржмрзНрж░рж╛ржЙржЬрж╛рж░рзЗ ржЖржорж░рж╛ URL ржжрж┐ржЗ (ржпрзЗржоржи: http://localhost:8080/)**

-   ржПржЗ request ржкрзНрж░ржержорзЗ ржпрж╛рзЯ router тЖТ router тЖТ server router ржПрж░ ржжрж┐ржХрзЗ (DNS resolve ржзрж░рзЗ ржирзЗржУржпрж╝рж╛ рж╣ржпрж╝рзЗржЫрзЗ)ред

**ЁЯФ╣ рзи. Server ржПрж░ Network Interface**

-   Server-side ржПрж░ Network Interface Controller (NIC) тАФ рж╣рждрзЗ ржкрж╛рж░рзЗ Ethernet Cable ржмрж╛ Wi-Fi Adapter тАФ ржПржЗ request ржзрж░рзЗред
-   ржПржЗ NIC data ржЧрзБрж▓рзЛ рж▓рзЗржЦрзЗ рждрж╛рж░ NIC Receive Buffer (RAM ржПрж░ ржПржХржЯрж╛ ржЕржВрж╢) ржПред

**ЁЯФ╣ рзй. NIC Interrupt **

-   ржпрзЗржЗ ржорзБрж╣рзВрж░рзНрждрзЗ NIC data ржкрж╛ржпрж╝, рж╕рзЗ рждржЦржи Interrupt Signal ржкрж╛ржарж╛ржпрж╝ Kernel ржХрзЗред
-   Kernel рждржЦржи ржПрж╕рзЗ NIC Receive Buffer ржерзЗржХрзЗ data ржкржбрж╝рзЗред

**ЁЯФ╣ рзк. Kernel тЖТ Socket Receive Buffer**

-   Kernel data ржХрзЗ write ржХрж░рзЗ Socket Receive Buffer ржП (ржпрзЗржЯрж╛ File Descriptor fd 5 ржПрж░ рж╕рж╛ржерзЗ ржпрзБржХрзНржд)ред

**ЁЯФ╣ рзл. Kernel тЖТ fd 5 Ready**

-   ржПрж░ржкрж░ Kernel fd 5 ржХрзЗ ready for read рж╣рж┐рж╕рзЗржмрзЗ mark ржХрж░рзЗред

**ЁЯФ╣ рзм. epoll_wait() тЖТ Wake Up**

-   ржпрзЗрж╣рзЗрждрзБ Go runtime epoll_wait() ржжрж┐ржпрж╝рзЗ ржЕржкрзЗржХрзНрж╖рж╛ ржХрж░ржЫрж┐рж▓, kernel ржПржЦржи:
    -   рж╕рзЗржЗ sleeping epoll_wait() thread ржХрзЗ wake ржХрж░рзЗред
    -   ржПржмржВ ржмрж▓рзЗ: тАЬfd 5 ржПржЦржи readyредтАЭ

**ЁЯФ╣ рзн. epoll_wait тЖТ Go Runtime**

-   epoll_wait() ржПржЗ fd 5 ржХрзЗ Go runtime ржПрж░ ржХрж╛ржЫрзЗ ржкрж╛ржарж╛ржпрж╝ред

**ЁЯФ╣ рзо. Go Runtime тЖТ Sleeping Goroutines**

-   Go runtime ржжрзЗржЦрзЗ, тАЬржПржЗ fd 5 ржПрж░ ржЬржирзНржп ржХрзЛржирзЛ goroutine ржЖржЧрзЗ ржерзЗржХрзЗ ржШрзБржорж┐ржпрж╝рзЗ ржЫрж┐рж▓рзЛ?тАЭ
-   ржпржжрж┐ ржерж╛ржХрзЗ, рждржмрзЗ рж╕рзЗржЗ goroutine ржХрзЗ wake ржХрж░рзЗред
-   ржПрж░ржкрж░ Go runtime ржПрж░ scheduler рж╕рзЗржЗ goroutine ржХрзЗ Local Run Queue рждрзЗ рж░рж╛ржЦрзЗред
-   ржПржХржЯрж┐ Logical Processor (P) рж╕рзЗржЗ goroutine ржЯрж┐ ржЪрж╛рж▓рж╛ржирзЛрж░ ржЬржирзНржп ржПржХржЯрж┐ dedicated OS thread (M) ржкрж╛ржпрж╝ред

**ЁЯФ╣ ЁЯФБ Execution рж╢рзБрж░рзБ**

-   рж╕рзЗржЗ Logical Processor ржПржЦржи main goroutine execute ржХрж░рзЗред
-   Go runtime fd 5 ржХрзЗ main goroutine ржПрж░ ржХрж╛ржЫрзЗ ржкрж╛ржарж╛ржпрж╝ред

**ЁЯФ╣ ЁЯФН Data Read рж╣рзЯ**

-   ржПржЦржи main goroutine fd 5 ржерзЗржХрзЗ data ржкржбрж╝рзЗ
-   socket receive buffer ржерзЗржХрзЗ data ржЖрж╕рзЗ
-   rw тЖТ data store рж╣рзЯ

**ЁЯФ╣ ЁЯЪА Serve ржХрж░рж╛рж░ ржЬржирзНржп ржирждрзБржи goroutine рждрзИрж░рж┐**

-   ржПрж░ржкрж░ Go runtime `go c.serve(connCtx)` ржХрж▓ ржХрж░рзЗ  
    -ржирждрзБржи ржПржХржЯрж╛ goroutine рждрзИрж░рж┐ рж╣ржпрж╝

ржПржЗ goroutine ржЯрж┐ rw рждрзЗ ржерж╛ржХрж╛ data ржмрзНржпржмрж╣рж╛рж░ ржХрж░рзЗ HTTP request handle ржХрж░рзЗред

**ЁЯФД ржкрж░ржмрж░рзНрждрзА request-ржПрж░ ржЬржирзНржп ржЕржкрзЗржХрзНрж╖рж╛**

-   ржПрж░ржкрж░ main goroutine ржЖржмрж╛рж░ `l.Accept()` ржП ржпрж╛ржпрж╝ред
-   Go runtime ржЬрж╛ржирзЗ ржпрзЗ ржЖржЧрзЗржЗ socket (fd 5) рждрзИрж░рж┐ рж╣ржпрж╝рзЗржЫрзЗред
-   рж╕рзЗ ржПржЦржи new incoming request ржПрж░ ржЬржирзНржп ржЕржкрзЗржХрзНрж╖рж╛ ржХрж░рзЗред

**ЁЯФБ ржирждрзБржи data ржПрж▓рзЗ ржЖржмрж╛рж░рзЛ ржПржХржЗ cycle**

-   NIC тЖТ kernel тЖТ socket receive buffer тЖТ mark fd ready тЖТ wake epoll_wait

-   Go runtime тЖТ wake goroutine тЖТ read тЖТ serve

ржПржнрж╛ржмрзЗржЗ ржПржХржЯрж┐ HTTP server concurrency + efficiency рж╕рж╣ржХрж╛рж░рзЗ thousands of connections handle ржХрж░рждрзЗ ржкрж╛рж░рзЗред

```markdown
Client Request (Browser)
тЖУ
Router тЖТ Server NIC тЖТ NIC Buffer (RAM)
тЖУ (Interrupt)
Linux Kernel тЖТ Copy to Socket Buffer (fd 5)
тЖУ
Mark fd 5 ready тЖТ Wake epoll_wait()
тЖУ
Go Runtime тЖТ Finds sleeping goroutine
тЖУ
Wake up тЖТ Scheduler тЖТ Local Run Queue тЖТ OS Thread
тЖУ
Execute main goroutine
тЖУ
main goroutine reads from fd 5 тЖТ rw = l.Accept()
тЖУ
go c.serve(connCtx) тЖТ spawn goroutine to handle
тЖУ
main goroutine again waits for next request...
```

### ЁЯУж Newly Spawned goroutine

-   ржпржЦржи `go c.serve(connCtx)` ржПрж░ ржорж╛ржзрзНржпржорзЗ ржПржХржЯрж┐ ржирждрзБржи goroutine spawn ржХрж░рж╛ рж╣ржпрж╝,
    рждржЦржи ржПржХржЯрж┐ ржирждрзБржи stack рждрзИрж░рж┐ рж╣ржпрж╝, ржПржмржВ ржПржЗ stack ржЯрж┐ heap memory ржПрж░ ржоржзрзНржпрзЗ рж╕ржВрж░ржХрзНрж╖рж┐ржд рж╣ржпрж╝ред
-   Go рждрзЗ goroutine ржПрж░ stack ржЫрзЛржЯ (ржкрзНрж░ржержорзЗ 2KB), ржХрж┐ржирзНрждрзБ ржПржЯрж┐ dynamic ржнрж╛ржмрзЗ ржмрж╛рзЬрждрзЗ ржкрж╛рж░рзЗред
-   ржПржЗ goroutine ржЯрж┐ рждрж╛рж░ржкрж░ local run queue рждрзЗ ржпрзБржХрзНржд рж╣ржпрж╝, ржпрзЗржЦрж╛ржирзЗ ржЕржирзЗржХ goroutine рж▓рж╛ржЗржи ржзрж░рзЗ ржЕржкрзЗржХрзНрж╖рж╛ ржХрж░рзЗред
-   ржкрзНрж░рждрж┐ржЯрж┐ logical processor (P) ржПрж░ рж╕рж╛ржерзЗ ржПржХржЯрж┐ dedicated OS thread (M) mapped ржерж╛ржХрзЗред ржПржЗ logical processor (P) рж╕рзЗржЗ local run queue ржерзЗржХрзЗ goroutine ржЯрж┐ржХрзЗ рждрзБрж▓рзЗ ржирзЗрзЯ ржПржмржВ execution рж╢рзБрж░рзБ ржХрж░рзЗред

> ЁЯз╡ goroutine spawn = тАЬржирждрзБржи ржПржХржЯрж┐ lightweight thread рждрзИрж░рж┐ ржХрж░рзЗ рж╕рзЗржЯрж╛ржХрзЗ ржЪрж╛рж▓рзБ ржХрж░рж╛редтАЭ

### тЬЕ mux ржПржмржВ handler execution ржзрж╛ржк:

-   ржПрж░ ржЖржЧрзЗ server ржПрж░ ржоржзрзНржпрзЗ mux (ржпрзЗржоржи `http.NewServeMux()`) рждрзИрж░рж┐ ржХрж░рж╛ рж╣ржпрж╝рзЗржЫрзЗ ржПржмржВ рж╕рзЗржЦрж╛ржирзЗ `HandleFunc()` ржПрж░ ржорж╛ржзрзНржпржорзЗ route ржУ handler function register ржХрж░рж╛ рж╣ржпрж╝рзЗржЫрзЗред
-   goroutine ржУржЗ router-ржПрж░ ржоржзрзНржпрзЗ ржЦрзБржБржЬрзЗ ржжрзЗржЦрзЗ, request-ржПрж░ URL path /about ржПрж░ ржорждрзЛ ржХрзЛржи route ржПрж░ рж╕рж╛ржерзЗ match ржХрж░рзЗ ржХрж┐ржирж╛ред
-   ржирждрзБржи goroutine ржпржЦржи ржЪрж╛рж▓рзБ рж╣ржпрж╝, рждржЦржи request-ржПрж░ URL path, header, ржПржмржВ ржЕржирзНржпрж╛ржирзНржп metadata ржжрзЗржЦрзЗ ржмрзЛржЭрж╛рж░ ржЪрзЗрж╖рзНржЯрж╛ ржХрж░рзЗ, ржХрзЛржи route ржмрж╛ path ржЯрж┐ ржорж┐рж▓рзЗ ржпрж╛ржЪрзНржЫрзЗред
-   ржпржЦржи ржПржХржЯрж┐ HTTP request ржЖрж╕рзЗ, рждржЦржи router ржЪрзЗржХ ржХрж░рзЗ рж╕рзЗржЗ URL path ржПрж░ рж╕рж╛ржерзЗ ржХрзЛржи pattern match ржХрж░ржЫрзЗ ржПржмржВ рж╕рзЗржЗ ржЕржирзБржпрж╛ржпрж╝рзА handler function execute ржХрж░рзЗред
    -   ржпрзЗржоржи goroutine ржУржЗ router-ржПрж░ ржоржзрзНржпрзЗ ржЦрзБржБржЬрзЗ ржжрзЗржЦрзЗ, request-ржПрж░ URL path `/about` ржПрж░ ржорждрзЛ ржХрзЛржи route ржПрж░ рж╕рж╛ржерзЗ match ржХрж░рзЗ ржХрж┐ржирж╛ред
    -   `/about` path ржПрж░ ржЬржирзНржп `aboutHandler()` ржирж╛ржорзЗрж░ handler function register ржХрж░рж╛ ржЖржЫрзЗред
-   handler match рж╣ржмрж╛рж░ ржкрж░, рж╕рзЗржЗ matched handler function ржПрж░ ржЬржирзНржп ржПржХржЯрж┐ ржирждрзБржи stack frame рждрзИрж░рж┐ рж╣ржпрж╝, ржпрж╛рждрзЗ ржУржЗ ржлрж╛ржВрж╢ржиржЯрж┐ рждрж╛рж░ ржХрзЛржб execute ржХрж░рждрзЗ ржкрж╛рж░рзЗред
    -   ржпржЦржи `aboutHandler()` ржЪрж╛рж▓рзБ рж╣рзЯ:
        -   рждрж╛рж░ ржЬржирзНржп ржПржХржЯрж┐ ржирждрзБржи stack frame рждрзИрж░рж┐ рж╣ржпрж╝, ржпрж╛рждрзЗ ржлрж╛ржВрж╢ржирзЗрж░ ржнрж┐рждрж░рзЗрж░ ржХрзЛржб execute ржХрж░рж╛ ржпрж╛ржпрж╝ред
        -   ржПржЗ ржлрж╛ржВрж╢ржи `w (response writer)` & `fprintln` ржПрж░ ржорж╛ржзрзНржпржорзЗ socket ржПрж░ ржХрж╛ржЫрзЗ `"About page"` write ржХрж░рзЗред
        -   socket send buffer ржП syscall ржПрж░ ржорж╛ржзрзНржпржорзЗ data store рж╣рзЯред

### ЁЯза NIC-ржП ржбрзЗржЯрж╛ ржпрж╛ржУрзЯрж╛рж░ ржкрзНрж░рж╕рзЗрж╕

-   **Go app ржерзЗржХрзЗ socket**
    -   fmt.Fprintln(w, "About page") тЖТ Go runtime ResponseWriter ржПрж░ ржнрж┐рждрж░рзЗ Write() method call ржХрж░рзЗ тЖТ ржЕржмрж╢рзЗрж╖рзЗ `syscall.Write()` ржПрж░ ржорж╛ржзрзНржпржорзЗ kernel _socket send buffer_ ржП data ржЬржорж╛ рж╣рзЯред
    -   `ResponseWriter.Write()` тЖТ ржЕржмрж╢рзЗрж╖рзЗ Go syscall layer-ржП ржЧрж┐рзЯрзЗ syscall.Write() call рж╣рзЯред
    -   `syscall.Write()` ржПрж░ ржорж╛ржзрзНржпржорзЗ data kernel space-ржП ржпрж╛рзЯ ржПржмржВ Socket Send Buffer ржП ржЬржорж╛ рж╣рзЯред
    -   Kernel рждржЦржи socket FD (File Descriptor) ржЕржирзБржпрж╛рзЯрзА check ржХрж░рзЗ data ready ржХрж┐ржирж╛ред
-   **Kernel ржерзЗржХрзЗ NIC**
    -   Kernel-ржПрж░ network stack рж╕рзЗржЗ data ржХрзЗ ржкрзНржпрж╛ржХрзЗржЯ ржХрж░рзЗ (TCP/IP header рж╕рж╣) NIC-ржПрж░ _TX (Transmit) ring buffer_-ржП рж▓рзЗржЦрж╛ рж╣рзЯ (ржПржЯрж╛ _hardware circular queue_)ред
-   **NIC ржкрзНржпрж╛ржХрзЗржЯ ржирзЗрзЯ ржПржмржВ Physical Layer-ржП ржкрж╛ржарж╛рзЯ**
    -   NIC Controller тЖТ DMA (Direct Memory Access) ржжрж┐рзЯрзЗ data ring buffer ржерзЗржХрзЗ ржкрзЬрзЗ тЖТ electromagnetic signal ржЖржХрж╛рж░рзЗ Ethernet cable / WiFi ржжрж┐рзЯрзЗ router/switch-ржПрж░ ржжрж┐ржХрзЗ ржкрж╛ржарж╛рзЯред
-   **Router hopping**
    -   ржПржХрж╛ржзрж┐ржХ router, switch ржПржмржВ network node ржкрж╛рж░ рж╣рзЯрзЗ destination client (user-ржПрж░ PC ржмрж╛ mobile) ржкрж░рзНржпржирзНржд ржкрзМржБржЫрж╛рзЯред
-   **Client receives**
    -   Client ржПрж░ NIC тЖТ OS тЖТ Browser тЖТ renders **"About page"**

```plaintext
+--------------------+               +-----------------+
|  Go Application    |               |     Kernel      |
|--------------------|               |-----------------|
| fmt.Fprintln(w,тАж)  |               |                 |
|   тЖУ                |               | syscall.Write() |
| ResponseWriter     |               |   тЖУ             |
|   тЖУ                |               | Socket Buffer   |
+--------------------+               |   тЖУ             |
                                     | NIC Driver      |
                                     +--------тЖУ--------+
                                              |
                           +------------------тЖУ-------------------+
                           |       NIC TX Ring Buffer (DMA)       |
                           +------------------тЖУ-------------------+
                                              |
                                 Electromagnetic Signal
                                              тЖУ
                                        Ethernet/WiFi
                                              тЖУ
                                           Router
                                              тЖУ
                                          Client PC
                                        "About page"

```

| Term                     | Meaning                                           |
| ------------------------ | ------------------------------------------------- |
| **Socket**               | 2-way data pipe, communication endpoint           |
| **File Descriptor (FD)** | kernel-assigned number for tracking sockets/files |
| **epoll_ctl**            | kernel ржХрзЗ ржмрж▓рж┐ тАФ тАЬржПржЗ socket ready рж╣рж▓рзЗ ржЖржорж╛ржХрзЗ ржЬрж╛ржирж┐ржУтАЭ |
| **epoll_wait**           | Go runtime waits here тАФ non-blocking              |
| **goroutine**            | Go-ржПрж░ ultra-light thread тАФ request handle ржХрж░рзЗ     |

[**Author:** @nazma98
**Date:** 2025-07-30
**Category:** interview-qa/class-wise
]
